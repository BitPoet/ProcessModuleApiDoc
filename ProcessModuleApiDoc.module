<?php namespace ProcessWire;

/**
 * Module Api Doc Viewer
 *
 * Copyright 2021 by BitPoet
 * https://github.com/BitPoet
 *
 * Licensed under the MIT license.
 * https://raw.githubusercontent.com/BitPoet/ProcessModuleApiDoc/main/LICENSE
 *
 * This module relies on composer package PHP-Parser which needs to be installed from the command line.
 * https://github.com/nikic/PHP-Parser
 * PHP-Parser is licensed under the terms of the BSD 3-Clause "New" or "Revised" License.
 *
 * ToDo:
 * This module could do with separating code and HTML.
 */
 
class ProcessModuleApiDoc extends Process implements ConfigurableModule {

	protected $seenPaths = [];
	protected $uninstalled = [];
	
	protected $fileDocLinkTemplate = "<a class='fa fa-file-text-o' href='%sview?module=%s&filename=%s' title='%s'> </a>";

	public static function getModuleInfo() {
		return [
			"title"			=>	__("Module Api Doc Viewer", __FILE__),
			"summary"		=>	__("Generate and view PHPDoc style documentation for site modules", __FILE__),
			"version"		=>	"0.0.8",
			"requires"		=>	["TextformatterMarkdownExtra", "ProcessWire>=3.0.127"],
			"icon"			=>	'file-text-o',
			"page"			=>	[
				"name"			=>	"moduledoc",
				"parent"		=>	"setup",
				"title"			=>	"Module API Docs",
			]
		];
	}
	
	public function init() {
		parent::init();
		$this->wire('modules')->get("JqueryWireTabs");
	}

	protected function docLink($classname, $filename, $title) {
		return sprintf(
			$this->fileDocLinkTemplate,
			$this->page->url,
			rawurlencode($classname),
			rawurlencode($filename),
			$title
		);
	}

	/**
	 * Default handler for Process
	 *
	 * Outputs an overview of installed modules and core classes along with links to the docs.
	 *
	 * @return string HTML
	 */
	public function ___execute() {
		
		// Installed Modules
		$fMods = $this->wire('modules')->get("InputfieldMarkup");
		$fMods->attr('name', 'installedmodules');
		$fMods->attr('value', $this->buildModulesTable());
		
		$uMods = $this->wire('modules')->get("InputfieldMarkup");
		$uMods->attr('name', 'uninstalledmodules');
		$uMods->attr('value', $this->buildUninstalledModulesTable());

		$fCore = $this->wire('modules')->get("InputfieldMarkup");
		$fCore->attr('name', 'coreclasses');
		$fCore->attr('value', $this->buildCoreTable());

		$fTpls = $this->wire('modules')->get("InputfieldMarkup");
		$fTpls->attr('name', 'templates');
		$fTpls->attr('value', $this->buildTemplatesTable($this->input->get->recurse));

		return $this->modules->get('JqueryWireTabs')->render([
			$this->_("Installed Modules")		=>	$fMods->render(),
			$this->_("Uninstalled Modules")		=>	$uMods->render(),
			$this->_("Core Classes")			=>	$fCore->render(),
			$this->_("Template Files")			=>	$fTpls->render()
		]);
	}
	
	public function ___buildModulesTable() {
		
		$out = "";
		$siteModules = [];
		$wireModules = [];

		foreach($this->modules as $module) {
			if($this->modules->isInstalled($module)) {
				$info = $this->modules->getModuleInfo($module);
				$className = $module->className();
				if(strpos($this->config->paths->$className, $this->config->paths->siteModules) === 0) {
					$siteModules[$className] = $info;
				} else {
					$wireModules[$className] = $info;
				}
				$this->seenPaths[] = $this->config->paths->$className;
			}
		}
		
		ksort($siteModules);
		ksort($wireModules);

		$out .= "<p> </p><div style='border: 1px solid gray; padding: 0.5em;'>" .
				"<p>" . $this->_("Click on the sheet symbol to the right of a class to view an on-the-fly generated documentation for the module.") . "</p>" .
				"<p>" . $this->_("Once there, you can also view the documentation for other PHP / module files in the same directory.") . "</p>" .
				"</div>";
		
		$out .= "<h2>" . $this->_("Site Modules") . "</h2>";
		
		$tbl = $this->modules->get("MarkupAdminDataTable");
		$tbl->setEncodeEntities(false);
		
		$tbl->headerRow([
			$this->_("Module"),
			$this->_("Title"),
			$this->_("Version"),
			$this->_("Action")
		]);
		
		foreach($siteModules as $className => $info) {
			$tbl->row([
				$className,
				$info['title'],
				$info['version'],
				$this->docLink($className, '', $this->_("View"))
			]);
		}
		
		$out .= $tbl->render();

		$out .= "<h2>" . $this->_("Wire (Core) Modules") . "</h2>";
		
		$tbl = $this->modules->get("MarkupAdminDataTable");
		$tbl->setEncodeEntities(false);
		
		$tbl->headerRow([
			$this->_("Module"),
			$this->_("Title"),
			$this->_("Version"),
			$this->_("Action")
		]);
		
		foreach($wireModules as $className => $info) {
			$tbl->row([
				$className,
				$info['title'],
				$info['version'],
				$this->docLink($className, '', $this->_("View"))
			]);
		}
		
		$out .= $tbl->render();
		
		return $out;
	}
	
	
	public function ___buildUninstalledModulesTable() {
		
		$out = "";

		$siteModules = $this->getFilesRecursive($this->config->paths->siteModules, ".module");
		$coreModules = $this->getFilesRecursive($this->config->paths->modules, ".module");
		
		// Site modules
		$out .= "<h2>" . $this->_("Site Modules") . "</h2>";
		
		$tbl = $this->modules->get("MarkupAdminDataTable");
		$tbl->setEncodeEntities(false);
		
		$tbl->headerRow([
			$this->_("File"),
			$this->_("Action")
		]);
		
		ksort($siteModules);
		foreach($siteModules as $className => $info) {
			$tbl->row([
				$className,
				$this->docLink($info, $className, $this->_("View"))
			]);
		}
		
		$out .= $tbl->render();
		
		// Core modules
		$out .= "<h2>" . $this->_("Core Modules") . "</h2>";
		
		$tbl = $this->modules->get("MarkupAdminDataTable");
		$tbl->setEncodeEntities(false);
		
		$tbl->headerRow([
			$this->_("File"),
			$this->_("Action")
		]);
		
		ksort($coreModules);
		foreach($coreModules as $className => $info) {
			$tbl->row([
				$className,
				$this->docLink($info, $className, $this->_("View"))
			]);
		}
		
		$out .= $tbl->render();
		
		return $out;
	}
	
	
	protected function getFilesRecursive($path, $ending) {
		
		$files = [];
		$directory = new \RecursiveDirectoryIterator($path);
		$iterator = new \RecursiveIteratorIterator($directory);

		foreach ($iterator as $info) {
			
			if($info->isDir() || substr(strtolower($info->getFilename()), -1 * strlen($ending)) !== strtolower($ending))
				continue;
			
			$path = $info->getPath() . "/";
			
			if(strtolower(substr($_SERVER['OS'], 0, 3)) === 'win')
				$path = str_replace('\\', '/', $path);
			
			if(in_array($path, $this->seenPaths))
				continue;
			
			$files[$info->getFilename()] = $path;
		}
		
		return $files;
	}
	
	
	public function ___buildTemplatesTable($recursive = false) {
		
		$files = [];
		
		if($recursive) {
			$directory = new \RecursiveDirectoryIterator($this->config->paths->templates);
			$iterator = new \RecursiveIteratorIterator($directory);

			foreach ($iterator as $info) {
				
				if($info->isDir() || substr(strtolower($info->getFilename()), -4) !== '.php')
					continue;
				
				$path = $info->getPath() . "/";
				
				if(strtolower(substr($_SERVER['OS'], 0, 3)) === 'win')
				$path = str_replace('\\', '/', $path);
				
				$files[] = [$path, $info->getFilename()];
			}
		} else {
			$path = $this->config->paths->templates;
			$dir = opendir($path);
			while(($file = readdir($dir)) !== false) {
				if(substr($file,0,1) !== '.' && is_file($path . $file) && substr($file, -4) === '.php') {
					$files[] = [$path, $file];
				}
			}
		}
		
		usort($files, function($a, $b) {
			$ord = strnatcmp($a[0], $b[0]);
			if($ord == 0) {
				$ord = strnatcmp($a[1], $b[1]);
			}
			return $ord;
		});
		
		$tbl = $this->modules->get("MarkupAdminDataTable");
		$tbl->setEncodeEntities(false);
		
		$tbl->headerRow([
			$this->_("File"),
			$this->_("Action")
		]);

		$oldPath = "";
		
		foreach($files as $f) {
			if($oldPath !== $f[0]) {
				$tbl->row([
					$this->_("Path") . ": " . $f[0],
					''
				], ['class' => 'rowdarker']);
			}
			$tbl->row([
				$f[1],
				$this->docLink($f[0], $f[1], $this->_("View"))
			]);
			$oldPath = $f[0];
		}

		return $tbl->render();
	}
	
	
	public function ___buildCoreTable() {
		$out = "";
		
		$dir = opendir($this->config->paths->core);

		$tbl = $this->modules->get("MarkupAdminDataTable");
		$tbl->setEncodeEntities(false);
		
		$tbl->headerRow([
			$this->_("File"),
			$this->_("Action")
		]);
		
		while(($file = readdir($dir)) !== false) {
			
			if(substr($file, 0, 1) == '.' || ! is_file($this->config->paths->core . $file) || ! preg_match('/\\.php$/i', $file))
				continue;
			
			$tbl->row([
				$file,
				$this->docLink('CORE', $file, $this->_("View"))
			]);
		}
		
		$out .= $tbl->render();
		
		return $out;
	}
	
	public function ___executeView() {

		require('ModuleApiDocGenerator.php');

		$out = "";

		$moduleName = $this->input->get->module;
		$moduleFile = $this->input->get->filename;
		
		if($moduleName === "CORE") {
			$modulePath = $this->config->paths->core;
			$path = $modulePath . $moduleFile;
		} else {
			if(strpos($moduleName, '/') !== false && $moduleFile) {
				$modulePath = $moduleName;
				$path = $moduleName . $moduleFile;
			} else {
				$modulePath = $this->config->paths->$moduleName;
				if($moduleFile) {
					$path = $this->config->paths->$moduleName . $moduleFile;
				} else {
					$path = $this->modules->getModuleFile($moduleName);
				}
			}
		}
		
		if(!$path) {
			return '<p><span class="fa fa-exclamation"> </span> ' . $this->_('Error: the module file could not be found!') . '</span></p>';
		}
		
		$out .= "<h4>" . sprintf($this->_("Viewing Documentation for File %s"), $path) . "</h4>";
		
		$otherfiles = [];
		
		if($moduleName !== "CORE") {
			$dir = opendir($modulePath);
			while(($file = readdir($dir)) !== false) {
				if(
					is_file($modulePath . $file)
					&& preg_match('/(php|module)$/i', $file)
					&& $file !== $moduleFile
					&& !($moduleFile == null && substr($path, -1 * strlen($file)) == $file)
				) {
					$otherfiles[] = $file;
				}
			}
		}
				
		if($otherfiles) {
			$out .= "<div><h4>" . $this->_("Other PHP files in this module's path") . "</h4><ul>";
			foreach($otherfiles as $file) {
				$out .= "<li><a href='{$this->page->url}view?module={$moduleName}&filename={$file}'>{$file}</a></li>";
			}
			$out .= "</ul></div>";
		}
		
		$gen = new ModuleApiDocGenerator($path);
		$gen->parse();
		
		$tfMd = $this->modules->get('TextformatterMarkdownExtra');
		
		$doc = $gen->buildDoc();
		foreach($doc as $name => $cls) {
			
			if($name === "NOCLASS") {
				// These are functions defined without a surrounding class
				$out .= '<h2>' . $this->_("Generated Documentation for File") . '</h2>';
				
				$clsParsed = $cls["parsedComment"];
				if($clsParsed) {
					$out .=  "<div style='border: 1px solid gray; padding: 0.5em;' class='markdown-wrap'>";
					if($clsParsed["summary"]) {
						$out .= "<h3>" . $clsParsed["summary"] . "</h3>";
					}
					if($clsParsed["description"]) {
						$out .= "" . $tfMd->markdown($clsParsed["description"]) . "";
					}
					$out .= "</div>";
				}

				$out .= "<h3>" . $this->_("Functions") . "</h3>";
				
				if(count($cls["functions"])) {
					$tbl = $this->modules->get("MarkupAdminDataTable");
					$tbl->setEncodeEntities(false);
					$tbl->headerRow([
						$this->_("Function"),
						$this->_("Description")
					]);
					foreach($cls["functions"] as $func) {
						$parsed = $func["parsedComment"];
						$tbl->row([
							"<strong>" . $func["name"] . "</strong>( " . $this->renderArgString($func["params"]) . " )",
							$parsed ? ("<p>" . $parsed["summary"] . "</p>" . ($parsed["description"] ? "<p style='white-space: pre-line;'>" . $tfMd->markdown($parsed["description"]) . "</p>" : "")) : ""
						], ['separator' => true, 'class' => 'rowdarker']);
						
					}
					$out .= $tbl->render();
				}
				
			} else {
				// A regular class
				$out .= '<h2>' . $this->_("Generated Documentation for Class") .': ' . $cls["namespace"] . '\\' . $name . '</h2>';
				
				$clsParsed = $cls["parsedComment"];
				if($clsParsed) {
					$out .=  "<div style='border: 1px solid gray; padding: 0.5em;' class='markdown-wrap'>";
					if($clsParsed["summary"]) {
						$out .= "<h3>" . $clsParsed["summary"] . "</h3>";
					}
					if($clsParsed["description"]) {
						$out .= "" . $tfMd->markdown($clsParsed["description"]) . "";
					}
					$out .= "</div>";
				}
							
				$out .= "<h3>" . $this->_("Properties") . "</h3>";
				if(count($cls["properties"])) {
					$tbl = $this->modules->get("MarkupAdminDataTable");
					$tbl->setEncodeEntities(false);
					$tbl->headerRow([
						$this->_("Property"),
						$this->_("Static"),
						$this->_("Description")
					]);
					foreach($cls["properties"] as $prop) {
						
						if($prop["visibility"] != "public") continue;
						
						$parsed = $prop["parsedComment"];
						$tbl = $tbl->row([
							'<strong>$' . $prop["name"] . "</strong>",
							$prop["scope"],
							$parsed ? ("<strong>" . $parsed["summary"] . "</strong>" . ($parsed["description"] ? "<p style='white-space: pre-line;'>" . $tfMd->markdown($parsed["description"]). "</p>" : "")) : ""
						], ['separator' => true, 'class' => 'rowdarker']);
					}
					$out .= $tbl->render();
				} else {
					$out .= "<p>" . $this->_("No properties defined") . "</p>";
				}
				
				$hooks = [];

				$out .= "<h3>" . $this->_("Methods") . "</h3>";
				$tbl = $this->modules->get("MarkupAdminDataTable");
				$tbl->setEncodeEntities(false);
				$tbl->headerRow([
					$this->_("Method"),
					$this->_("Static"),
					$this->_("Description")
				]);
				foreach($cls["methods"] as $meth) {
					
					if($meth["visibility"] != "public") continue;
					if(substr($meth["name"], 0, 3) == '___') {
						$hooks[] = $meth;
						continue;
					}

					$parsed = $meth["parsedComment"];
					$tbl->row([
						"<strong>" . $meth["name"] . "</strong>( " . $this->renderArgString($meth["params"]) . " )",
						$meth["scope"],
						$parsed ? ("<p>" . $parsed["summary"] . "</p>" . ($parsed["description"] ? "<p style='white-space: pre-line;'>" . $tfMd->markdown($parsed["description"]) . "</p>" : "")) : ""
					], ['separator' => true, 'class' => 'rowdarker']);
					
					if($parsed && $parsed["returns"] && $parsed["returns"]["type"] ) {
						$tbl->row([
							'',
							$this->_("returns:"),
							$parsed["returns"]["type"] . " <em>" . $parsed["returns"]["text"] . "</em>"
						]);
					}
					
					if($parsed && $parsed["params"] && count($parsed["params"]) > 0) {
						foreach($parsed["params"] as $prm) {
							$tbl->row([
								'',
								$this->_("argument:"),
								" <em>" . $prm["type"] . "</em> <span style='color: blue;'>" . $prm["name"] . "</span>" . ($prm["text"] ? " - " . $prm["text"] : "")
							]);
						}
					}
				}
				$out .= $tbl->render();

				if(count($hooks)) {
					$out .= "<h3>" . $this->_("Hookable Methods") . "</h3>";
					$tbl = $this->modules->get("MarkupAdminDataTable");
					$tbl->setEncodeEntities(false);
					$tbl->headerRow([
						$this->_("Method"),
						$this->_("Static"),
						$this->_("Description")
					]);
					foreach($hooks as $meth) {
						
						$parsed = $meth["parsedComment"];
						$tbl->row([
							"<strong>" . substr($meth["name"], 3) . "</strong>( " . $this->renderArgString($meth["params"]) . " )",
							$meth["scope"],
							$parsed ? ("<p>" . $parsed["summary"] . "</p>" . ($parsed["description"] ? "<p style='white-space: pre-line;'>" . $tfMd->markdown($parsed["description"]) . "</p>" : "")) : ""
						], ['separator' => true, 'class' => 'rowdarker']);

						if($parsed && $parsed["returns"] && $parsed["returns"]["type"] ) {
							$tbl->row([
								'',
								$this->_("return:"),
								$parsed["returns"]["type"] . " <em>" . $parsed["returns"]["text"] . "</em>"
							]);
						}
						
						if($parsed && $parsed["params"] && count($parsed["params"]) > 0) {
							foreach($parsed["params"] as $prm) {
								$tbl->row([
									'',
									$this->_("argument:"),
									" <em>" . $prm["type"] . "</em> <span style='color: blue;'>" . $prm["name"] . "</span>" . ($prm["text"] ? " - " . $prm["text"] : "")
								]);
							}
						}
					}
					$out .= $tbl->render();
				}

				if($clsParsed && $clsParsed["todo"]) {
					$out .= "<div class='mad-todo'>"
							. "<h3>" . $this->_("Open todos") . "</h3><ul>"
							. implode("\n", array_map(function($line) use($tfMd) {
								return "<li>" . $tfMd->markdown(htmlentities($line)) . "</li>";
							}, $clsParsed["todo"]))
							. "</ul></div>";
				}
			}
		}
		
		return $out;
	}
	
	protected function renderArgString($params) {
		return implode(', ', array_map(
			function($param) {
				return "<em>" . $param["type"] . "</em>" .
					   ' <span style="color: blue;">$' . $param["name"] . "</span>" . ($param["default"] ? " = " . $param["default"] : "");
			},
			$params
		));
	}
	
	
	public static function getModuleConfigInputfields($data) {
		$wrap = new InputfieldWrapper();
		
		$f = wire('modules')->get("InputfieldMarkup");
		$f->title = __("Install php-parser before usage!", __FILE__);
		$f->attr(
			'value',
			__("Before using this module, you have to go into the module directory in a shell and execute 'composer update'.", __FILE__) . "\n"
			. sprintf(__("This will install the necessary [PHP-Parser](%s) package.", __FILE__), "https://github.com/nikic/PHP-Parser") . "\n"
			. "\n"
			. __("It is recommended to install this module in *development environments* only!")
		);
		$f->set("textformatters", ["TextformatterMarkdownExtra"]);
		
		$wrap->append($f);
		
		return $wrap;
	}
	
}
